<html>

<head>
    <!-- <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/base-min.css"/> -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
        integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
        integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
        integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
        crossorigin="anonymous"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.20.0/cytoscape.min.js"
        integrity="sha512-cjmYAonfXK+azDmWqvnqq8xmygHRHqVI7S0zuRxQnvcYVeoakwthRX6pPKoXfG1oIjDvMUtteRV9PhQjJwKWxQ=="
        crossorigin="anonymous"></script> -->
        <script src="{{url_for('static', filename='cytoscape.min.js')}}"></script> 
        
        <!-- fcose layout test: -->
        <script src="https://unpkg.com/layout-base/layout-base.js"></script>
        <script src="https://unpkg.com/cose-base/cose-base.js"></script>
        <script src="https://unpkg.com/cytoscape-fcose/cytoscape-fcose.js"></script>
        <!-- cose bilkent test -->
        <!-- <script src="https://unpkg.com/layout-base/layout-base.js"></script>
        <script src="https://unpkg.com/cose-base/cose-base.js"></script>
        <script src="cytoscape-cose-bilkent.js"></script> -->
    <title> Annotations</title>
    <h1>Annotations</h1>
</head>

<body style="margin:2em;padding:10px">
    <h4>Got theories</h4>
    {{theories|safe}}

    <div id="cy"></div>

</html>
<style>
    #cy {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
    }
</style>

<script type="text/javascript">
    //on window load:
    $(document).ready(function(){
        // var theoriesA = "{{ theories| safe}}";
        //     var cy = cytoscape({
        //         container: document.getElementById('cy'), // container to render in
        //         elements: {
        //             nodes: [],
        //             edges: []
        //         },

        // });
        //    cy.add("{{cyjs | safe}}");
        //    console.log(cy);
        // var cyto = {{cyjs}};
        // var cyto = "{{cyjs}}"
        // var cyto = {{cyjs | safe}};
        // var cyto = "{{cyjs | safe}}";
//         var cyto = {};
//         cyto ={{cyjs | tojson }};
//     //    var cyto = JSON.parse("{{cyjs | safe}}");
//         // print("got cyto: " + cyto);
        cyto = {{cyjs | tojson | safe}};

        console.log("got cyto", cyto);

        var cy = cytoscape({

        container: document.getElementById('cy'), // container to render in

        elements: cyto,
        // data: [ {{cyjs | tojson | safe}} ],
        // "data": {"name": "G", "graph": {"fontname": "Verdana", "fontcolor": "green", "fontsize": "12"}}, 
        // "elements": {"nodes": [{"data": {"color": "red", "id": "Somatic marker processes", "name": "Somatic marker processes"}}, 
        // {"data": {"color": "red", "id": "Anticipated emotions", "name": "Anticipated emotions"}}]},
        // elements: [ // list of graph elements to start with
        //     { // node a
        //         data: { id: 'a very long label here' }
        //     },
        //     { // node b
        //         data: { id: 'b' }
        //     },
        //     { // edge ab
        //         data: { id: 'ab', source: 'a very long label here', target: 'b' }
        //     }
        // ],

        style: [ // the stylesheet for the graph
            {
                selector: 'node',
                style: {
                    // 'width': '200',
                    //todo: width and height 'label' deprecated. see https://stackoverflow.com/questions/68399821/cytoscape-js-warning-the-style-value-of-label-is-deprecated-for-width-whe
                    'width': 'label',
                    'height': 'label',
                    'shape': 'ellipse',
                    'background-color': 'data(color)',
                    'label': 'data(id)',
                    //label inside node:
                    'text-halign': 'center',
                    'text-valign': 'center',
                }
            },

            {
                selector: 'edge',
                style: {
                    'width': 3,
                    'line-color': '#000',
                    'target-arrow-color': '#000',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier'
                }
            },
            // test parent styling
            {
            selector: 'parent',
                style: {
                    'border-color': 'data(parentColor)',
                    'line-color': 'black',
                    'target-arrow-color': 'black',
                    'source-arrow-color': 'black'
                }
            }
        ],

        layout: {
            // name: 'grid',
            // rows: 3,

            // name:'random',
            // fit: true, // whether to fit to viewport
            // padding: 30, // fit padding
            // boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
            // animate: false, // whether to transition the node positions
            // animationDuration: 500, // duration of animation in ms if enabled
            // animationEasing: undefined, // easing of animation if enabled
            // animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
            // ready: undefined, // callback on layoutready
            // stop: undefined, // callback on layoutstop
            // transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts 

            // name: 'concentric',

            // fit: true, // whether to fit the viewport to the graph
            // padding: 5, // the padding on fit
            // startAngle: 3 / 2 * Math.PI, // where nodes start in radians
            // sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
            // clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
            // equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
            // minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
            // boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
            // avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
            // nodeDimensionsIncludeLabels: false, // Excludes the label when calculating node bounding boxes for the layout algorithm
            // height: undefined, // height of layout area (overrides container height)
            // width: undefined, // width of layout area (overrides container width)
            // spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
            // concentric: function( node ){ // returns numeric value for each node, placing higher nodes in levels towards the centre
            // return node.degree();
            // },
            // levelWidth: function( nodes ){ // the variation of concentric values in each level
            // return nodes.maxDegree() / 4;
            // },
            // animate: false, // whether to transition the node positions
            // animationDuration: 500, // duration of animation in ms if enabled
            // animationEasing: undefined, // easing of animation if enabled
            // animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
            // ready: undefined, // callback on layoutready
            // stop: undefined, // callback on layoutstop
            // transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts


            // name: 'breadthfirst',
            // fit: false, // whether to fit the viewport to the graph
            // directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
            // padding: 30, // padding on fit
            // circle: true, // put depths in concentric circles if true, put depths top down if false
            // grid: false, // whether to create an even grid into which the DAG is placed (circle:false only)
            // spacingFactor: 0.5, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
            // boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
            // avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
            // nodeDimensionsIncludeLabels: true, // Excludes the label when calculating node bounding boxes for the layout algorithm
            // roots: undefined, // the roots of the trees
            // maximal: false, // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
            // animate: true, // whether to transition the node positions
            // animationDuration: 500, // duration of animation in ms if enabled
            // animationEasing: undefined, // easing of animation if enabled,
            // animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
            // ready: undefined, // callback on layoutready
            // stop: undefined, // callback on layoutstop
            // transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts

            // name: 'cose',

            // // Called on `layoutready`
            // ready: function(){},

            // // Called on `layoutstop`
            // stop: function(){},

            // // Whether to animate while running the layout
            // // true : Animate continuously as the layout is running
            // // false : Just show the end result
            // // 'end' : Animate with the end result, from the initial positions to the end positions
            // animate: true,

            // // Easing of the animation for animate:'end'
            // animationEasing: undefined,

            // // The duration of the animation for animate:'end'
            // animationDuration: undefined,

            // // A function that determines whether the node should be animated
            // // All nodes animated by default on animate enabled
            // // Non-animated nodes are positioned immediately when the layout starts
            // animateFilter: function ( node, i ){ return true; },


            // // The layout animates only after this many milliseconds for animate:true
            // // (prevents flashing on fast runs)
            // animationThreshold: 250,

            // // Number of iterations between consecutive screen positions update
            // refresh: 200,

            // // Whether to fit the network view after when done
            // fit: false,

            // // Padding on fit
            // padding: 30,

            // // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
            // boundingBox: undefined,

            // // Excludes the label when calculating node bounding boxes for the layout algorithm
            // nodeDimensionsIncludeLabels: false,

            // // Randomize the initial positions of the nodes (true) or use existing positions (false)
            // randomize: false,

            // // Extra spacing between components in non-compound graphs
            // componentSpacing: 40,

            // // Node repulsion (non overlapping) multiplier
            // nodeRepulsion: function( node ){ return 3048; },

            // // Node repulsion (overlapping) multiplier
            // nodeOverlap: 15,

            // // Ideal edge (non nested) length
            // idealEdgeLength: function( edge ){ return 32; },

            // // Divisor to compute edge forces
            // edgeElasticity: function( edge ){ return 32; },

            // // Nesting factor (multiplier) to compute ideal edge length for nested edges
            // nestingFactor: 1.2,

            // // Gravity force (constant)
            // gravity: 1,

            // // Maximum number of iterations to perform
            // numIter: 3000,

            // // Initial temperature (maximum node displacement)
            // initialTemp: 3000,

            // // Cooling factor (how the temperature is reduced between consecutive iterations
            // coolingFactor: 0.99,

            // // Lower temperature threshold (below this point the layout will end)
            // minTemp: 1.0

            name: 'fcose',
            // 'draft', 'default' or 'proof' 
            // - "draft" only applies spectral layout 
            // - "default" improves the quality with incremental layout (fast cooling rate)
            // - "proof" improves the quality with incremental layout (slow cooling rate) 
            quality: "proof",
            // Use random node positions at beginning of layout
            // if this is set to false, then quality option must be "proof"
            randomize: false, 
            // Whether or not to animate the layout
            animate: true, 
            // Duration of animation in ms, if enabled
            animationDuration: 1000, 
            // Easing of animation, if enabled
            animationEasing: undefined, 
            // Fit the viewport to the repositioned nodes
            fit: true, 
            // Padding around layout
            padding: 30,
            // Whether to include labels in node dimensions. Valid in "proof" quality
            nodeDimensionsIncludeLabels: true,
            // Whether or not simple nodes (non-compound nodes) are of uniform dimensions
            uniformNodeDimensions: false,
            // Whether to pack disconnected components - cytoscape-layout-utilities extension should be registered and initialized
            packComponents: true,
            // Layout step - all, transformed, enforced, cose - for debug purpose only
            step: "all",
            
            /* spectral layout options */
            
            // False for random, true for greedy sampling
            samplingType: true,
            // Sample size to construct distance matrix
            sampleSize: 25,
            // Separation amount between nodes
            nodeSeparation: 75,
            // Power iteration tolerance
            piTol: 0.0000001,
            
            /* incremental layout options */
            
            // Node repulsion (non overlapping) multiplier
            nodeRepulsion: node => 45000,
            // Ideal edge (non nested) length
            idealEdgeLength: edge => 50,
            // Divisor to compute edge forces
            edgeElasticity: edge => 0.15,
            // Nesting factor (multiplier) to compute ideal edge length for nested edges
            nestingFactor: 0.6,
            // Maximum number of iterations to perform - this is a suggested value and might be adjusted by the algorithm as required
            numIter: 2500,
            // For enabling tiling
            tile: true,  
            // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
            tilingPaddingVertical: 10,
            // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
            tilingPaddingHorizontal: 10,
            // Gravity force (constant)
            gravity: 0.25,
            // Gravity range (constant) for compounds
            gravityRangeCompound: 1.5,
            // Gravity force (constant) for compounds
            gravityCompound: 1.0,
            // Gravity range (constant)
            gravityRange: 3.8, 
            // Initial cooling factor for incremental layout  
            initialEnergyOnIncremental: 0.3,

            /* constraint options */

            // Fix desired nodes to predefined positions
            // [{nodeId: 'n1', position: {x: 100, y: 200}}, {...}]
            fixedNodeConstraint: undefined,
            // Align desired nodes in vertical/horizontal direction
            // {vertical: [['n1', 'n2'], [...]], horizontal: [['n2', 'n4'], [...]]}
            alignmentConstraint: undefined,
            // Place two nodes relatively in vertical/horizontal direction
            // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}, {...}]
            relativePlacementConstraint: undefined,

            /* layout event callbacks */
            ready: () => {}, // on layoutready
            stop: () => {} // on layoutstop


        }

        });
        cy.$('#cy').lock(); //this not working

        var collection = cy.collection();
        cy.nodes().on('click', function(e){
        var clickedNode = e.target;

        collection = collection.union(clickedNode);
        console.log(collection);
        });

        console.log("loaded");
        cycy = cy.filter(function(element, i){
                if( element.isNode() && element.data('color') == 'cyan'){
                    console.log(element.data('label'));
                    return(element.data('label'));
                }
            });
        // cycy = cy.nodes('[background-color == "cyan"]');
        console.log("cycy: " + cycy);
        // cy.add(cyto);
        // cyto = JSON.parse({{cyjs|safe}});
        // try {
        //     // cyto = JSON.parse({{cyjs|safe}});
        //     cyto = {{cyjs | safe}}; 
        // } catch (error) {
        //     console.log('Error parsing JSON:', error, data);
        //     cyto = {};
        // }
        // // cyto = JSON.parse({{ cyjs | safe}});
        // // cyto = {{cyjs | safe}};
        // // cy.add(cyto);
        // console.log(cyto)
        // cy.add(

        // )
        // for (var i = 0; i < theoriesA.length; i++ ) {
        //     console.log("theory: " + theoriesA[i]);
        //     cy.add({
        //         data: {
        //             id: theoriesA[i]
        //         }
        //     });
        // }
    });

</script>